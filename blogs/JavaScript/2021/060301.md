---
title: 设计模式
date: 2021-6-03
categories:
 - JavaScript
author: Junjl
tags:
 - 设计模式
---

## 工厂模式
工厂模式是用来创建对象的一种最常用的设计模式。不暴露创建对象的具体逻辑,而是将逻辑封装在一个函数中,那么这个函数就视为一个工厂。

### 简单工厂模式
```js
function Animal(opts) {
  let obj = new Object();
  obj.color = opts.color;
  obj.name = opts.name;
  obj.getInfo = function() {
    return '名称' + obj.name + ',颜色' + obj.color;
  }
  return obj;
}
let cat = Animal({name: '波斯猫', color: '白色'});
```
### 工厂方法模式
```js
class User {
  constructor(name = '', viewPage = []) {
    if (new.target === User) {
      throw new Error('抽象类不能实例化');
    }
    this.name = name;
    this.viewPage = viewPage;
  }
}

class UsaerFactory extends User {
  constructor(name, viewPage) {
    super(name, viewPage)
  }
  create(role) {
    switch (role) {
      case 'superAdmin':
        return new UserFactory('超级管理员', ['首页', '通讯录', '发现页', '应用数据', '权限管理'])
        break;
      case 'admin':
        return new UserFactory('普通管理员', ['首页', '通讯录', '发现页'])
        break;
      case 'user':
        return new UserFactory('普通用户', ['首页', '通讯录', '发现页'])
        break;
      default:
        throw new Error('参数错误, 可选参数有:superAdmin,admin,user')
    }
  }
}

let userFactory = new UserFactory();
let superAdmin = userFactory.create('superAdmin');
let admin = userFactory.create('admin');
let user = userFactory.create('user');
```

### 抽象工厂模式
```js
class getAbstractUserFactory(type) {
  switch (type) {
    case 'wechat':
      return UserOfWechat;
      break;
    case 'qq':
      return UserOfQq;
      break;
    case 'weibo':
      return UserOfWeibo;
      break;
    default:
      throw new Error('参数错误, 可选参数有:wechat,qq,weibo')
  }
}

let WechatUserClass = getAbstractUserFactory('wechat');
let QqUserClass = getAbstractUserFactory('qq');
let WeiboUserClass = getAbstractUserFactory('weibo');

let wechatUser = new WechatUserClass('微信小李');
let qqUser = new QqUserClass('QQ小李');
let weiboUser = new WeiboUserClass('微博小李');
```

## 单例模式
保证一个类仅有一个实例 利用闭包
在vuex中, 通过一个外部变量来控制全局只有一个Vue实例
## 适配器模式
适配器用来解决两个接口不兼容的情况, 不需要改变已有的接口, 通过包装一层的方式实现两个接口的正常协作
## 装饰模式
装饰者模式不需要改变已有的接口, 给对象添加额外的功能。比如使用ES7中的装饰器语法
## 代理模式
在某些情况下,一个对象不适合或者不能直接引用另一个对象, 而代理对象可以在两个对象之间起到中介作用  
此外, 还有ES6的proxy, 也就是在目标对象之前架设一层拦截, 或者叫代理
## 观察者模式
定义了对象间一对多的依赖关系, 当目标对象的状态发生改变时, 所有依赖它的对象都会得到通知  
vue源码中的依赖管理和通知更新就是基于观察者模式
## 发布订阅模式
实现了对象间多对多的依赖关系, 通过事件中心管理多个事件。目标对象并不直接通知观察者,而是通过事件中心派发通知